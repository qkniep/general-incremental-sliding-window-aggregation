"""."""

import math


class FlatFAT:
    """."""

    # F = FlatFAT([(3, 4), (6, 2), (8, 1), (5, 3), (1, 4), (4, 1)], "operator")
    def __init__(self, values, operator):
        self.capacity = int(math.ceil(math.log2(len(values))))
        self.capacity = int(math.pow(2, self.capacity))

        self.values = values

        self.size = (2 * self.capacity) - 1
        self.tree = [None] * self.size
        self.values = [None] * self.capacity
        self.largest_location = len(values)-1

        self.operator = operator

        self.__newStructure(values)

    def __newStructure(self, values):
        start = self.size - self.capacity
        # write leafs
        for i in range(start, start + len(values)):
            self.tree[i] = values[i-start]
            self.values[i-start] = values[i-start]

        # find intermediate states
        for i in range(self.size-1, 0, -2):
            parent = self.__getParent(i)
            combine_result = self.__combine(self.tree[i], self.tree[i-1])
            self.tree[parent] = combine_result

    def resize(self, size, enlarge=True):
        print("")
        print(self.tree)
        # capacity = int(math.ceil(math.log2(size)))
        # capacity = int(math.pow(2, capacity))
        capacity = size
        values_tmp = [None] * capacity

        # create new values array of correct size
        if enlarge:  # enlarge
            for i in range(0, self.capacity):
                values_tmp[i] = self.values[i]
        else:  # shrink
            for i in range(0, capacity):
                values_tmp[i] = self.values[i]

        # create new instance of FlatFat
        tmp_tree = FlatFAT(values_tmp, self.operator)

        # overwrite instance variables of self
        self.tree = tmp_tree.tree
        self.capacity = tmp_tree.capacity
        self.values = tmp_tree.values
        self.size = tmp_tree.size
        print(self.tree)
        print("")

    def __getParent(self, i):
        if i % 2 == 0:
            parent_node = int((i/2)-1)
        else:
            parent_node = int(i/2)

        return parent_node

    def __combine(self, v, w):
        if v is None:
            return w
        if w is None:
            return v
        return self.operator.combine(v, w)

    def __getMaxIndex(self):
        for i in range(int(len(self.values)/2+1), 0, -1):
            if self.values[i] is not None:
                self.largest_location = i
                break

    # assumption: value is a list of tuples: [(location, (id, value, ..)), ..]
    # eg value = [(4, None), (15, (1, 9)), (3, (9, 11))]
    def update(self, changes):
        for pos, value in changes:
            self.tree[self.leaf_pos(pos)] = value
            self.values[pos] = value
        dirty = {self.__getParent(self.leaf_pos(pos)) for pos, _ in changes}

        # update intermediate states
        for i in dirty:
            l_child = self.tree[left(i)]
            r_child = self.tree[right(i)]
            children_combined = self.__combine(l_child, r_child)

            if (
                self.__combine(self.tree[i], children_combined)
                == children_combined
            ):
                self.tree[i] = children_combined
                parent_node = self.__getParent(i)
                if i == 0:
                    break
                dirty.append(parent_node)

        print(self.tree)

    def aggregate(self):
        return self.tree[0]

    def leaf_pos(self, pos):
        return self.size - self.capacity + pos

    # TODO no new tree but O(log)?
    def prefix(self, i):
        prefix = self.values[0:i]
        prefix_tree = FlatFAT(prefix, self.operator)

        return prefix_tree.tree[0]

    # TODO no new tree but O(log)?
    def suffix(self, j):
        suffix = self.values[j:]
        suffix_tree = FlatFAT(suffix, self.operator)

        return suffix_tree.tree[0]


def left(i):
    return (i * 2) + 1


def right(i):
    return (i * 2) + 2
